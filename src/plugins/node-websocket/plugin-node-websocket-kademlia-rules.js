const ContactAddressProtocolType = require('../contact-type/contact-address-protocol-type')
const IsomorphicWebSocket = require('isomorphic-ws')
const bencode = require('bencode');
const BufferHelper = require('../../helpers/buffer-utils')
const ContactType = require('../contact-type/contact-type')
const PromisesMap = require('../../helpers/promises-map')

const WebSocketServer = typeof BROWSER === "undefined" ? require('./web-socket-server') : undefined;
const PluginNodeWebsocketConnectionSocket = require('./connection/websocket-connection-socket')

module.exports = function (options){

    return class MyRules extends options.Rules{

        constructor() {

            super(...arguments);

            this._webSocketActiveConnections = [];
            this._webSocketActiveConnectionsMap = {};
            this._webSocketActiveConnectionsByContactsMap = {};

            if (!this._skipProtocolEncryptions) this._skipProtocolEncryptions = {};

            this.PluginNodeWebsocketConnectionSocketClass = PluginNodeWebsocketConnectionSocket;

            /**
             * Connection Handshake is considered not safe as the certificate can be generated by a hijacked dns. So, Connection Handshake will require forced encryption using public keys.
             * Once the connection handshake is verified, the SSL is considered safe as their is proof from both parties of owning the private keys of the contact public keys.
             */
            this._skipProtocolEncryptions[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED] = true;

            if (ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET === undefined) throw new Error('WebSocket protocol was not initialized.');
            this._protocolSpecifics[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET] =
            this._protocolSpecifics[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED] = {
                sendSerialize: this._websocketSendSerialize.bind(this),
                sendSerialized: this._websocketSendSerialized.bind(this),
                receiveSerialize: this._websocketReceiveSerialize.bind(this),
            }

        }

        async _establishConnection(dstContact){

            if (dstContact.contactType === ContactType.CONTACT_TYPE_ENABLED)
                return this._createWebSocket(dstContact, dstContact.convertProtocolToWebSocket()  );

            return super._establishConnection(dstContact);
        }

        async start(opts){

            const out = await super.start(opts);

            //Node.js
            if ( typeof BROWSER === "undefined" && this._kademliaNode.plugins.hasPlugin('PluginNodeHTTP') )
                this._webSocketServer = new WebSocketServer(this._kademliaNode, {
                    server: this._httpServer.server,
                    'Access-Control-Allow-Origin': "*",
                });

            return out;
        }

        stop(){
            return super.stop(...arguments);
        }

        async _createWebSocket(  dstContact, protocol ) {

            let address = dstContact.hostname +':'+ dstContact.port + dstContact.path;

            const data = await this._sendProcess(dstContact, protocol, [ this._kademliaNode.contact.toArray(), ''], {forceEncryption: true});

            if (protocol === ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET) address = 'ws://'+address;
            else if (protocol === ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED) address = 'wss://'+address;
            else throw 'invalid protocol type';

            if (!this._checkWebSocket(dstContact))
                throw 'Already connected';

            const ws = new IsomorphicWebSocket(address, data.toString('hex') );

            return  new this.PluginNodeWebsocketConnectionSocketClass(this, ws, dstContact, true );

        }



        _websocketSendSerialize (dstContact, command, data) {
            const id = Math.floor( Math.random() * Number.MAX_SAFE_INTEGER );
            return {
                id,
                out: [ command, data ],
            }
        }

        async _websocketSendSerialized (id, dstContact, protocol, command, data)  {

            const buffer = bencode.encode( [0, id, data] );

            //connected once already already
            let connection = this._webSocketActiveConnectionsByContactsMap[dstContact.identityHex];
            if (!connection)
                connection = await this._createWebSocket( dstContact, protocol );

            return connection.sendConnectionWaitAnswer( id, buffer);
        }

        _websocketReceiveSerialize (id, srcContact, out ) {
            return bencode.encode( BufferHelper.serializeData([ 1, id, out] ) )
        }

        _checkWebSocket( contact ){

            if (contact.contactType === ContactType.CONTACT_TYPE_ENABLED ){

                const address = contact.hostname +':'+ contact.port + contact.path;

                //connected twice
                if (this._webSocketActiveConnectionsMap[address] || this.alreadyConnected[contact.identityHex])
                    return false;

            }

            return true;
        }


    }


}