const ContactAddressProtocolType = require('../contact-type/contact-address-protocol-type')
const IsomorphicWebSocket = require('isomorphic-ws')
const bencode = require('bencode');
const BufferHelper = require('../../helpers/buffer-utils')
const ContactType = require('../contact-type/contact-type')

const WebSocketServer = typeof BROWSER === "undefined" ? require('./web-socket-server') : undefined;
const PluginNodeWebsocketExtends = require('./plugin-node-websocket-extends')

module.exports = function (options){

    return class MyRules extends options.Rules{

        constructor() {

            super(...arguments);

            this._webSocketActiveConnections = [];
            this._webSocketActiveConnectionsMap = {};
            this._webSocketActiveConnectionsByContactsMap = {};

            if (!this._skipProtocolEncryptions) this._skipProtocolEncryptions = {};

            this.PluginNodeWebsocketExtends = PluginNodeWebsocketExtends(Object);

            /**
             * Connection Handshake is considered not safe as the certificate can be generated by a hijacked dns. So, Connection Handshake will require forced encryption using public keys.
             * Once the connection handshake is verified, the SSL is considered safe as their is proof from both parties of owning the private keys of the contact public keys.
             */
            this._skipProtocolEncryptions[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED] = true;

            if (ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET === undefined) throw new Error('WebSocket protocol was not initialized.');
            this._protocolSpecifics[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET] =
            this._protocolSpecifics[ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED] = {
                sendSerialize: this._websocketSendSerialize.bind(this),
                sendSerialized: this._websocketSendSerialized.bind(this),
                receiveSerialize: this._websocketReceiveSerialize.bind(this),
            }

        }

        establishConnection(dstContact, cb){

            if (dstContact.contactType === ContactType.CONTACT_TYPE_ENABLED)
                return this._createWebSocket(dstContact, dstContact.convertProtocolToWebSocket(), cb );

            return super.establishConnection(dstContact, cb);
        }

        async start(opts){

            const out = await super.start(opts);

            this.pluginNodeWebsocketExtends = new this.PluginNodeWebsocketExtends();

            //Node.js
            if ( typeof BROWSER === "undefined" && this._kademliaNode.plugins.hasPlugin('PluginNodeHTTP') )
                this._webSocketServer = new WebSocketServer(this._kademliaNode, {
                    server: this._httpServer.server,
                    'Access-Control-Allow-Origin': "*",
                });


            return out;
        }

        stop(){
            return super.stop(...arguments);
        }

        _createWebSocket(  dstContact, protocol, cb ) {

            let address = dstContact.hostname +':'+ dstContact.port + dstContact.path;

            const data = [ this._kademliaNode.contact.toArray(), ''];
            this._sendProcess(dstContact, protocol, data, {forceEncryption: true}, (err, data) =>{

                if (err) return cb(err);

                if (protocol === ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET) address = 'ws://'+address;
                else if (protocol === ContactAddressProtocolType.CONTACT_ADDRESS_PROTOCOL_TYPE_WEBSOCKET_SECURED) address = 'wss://'+address;
                else return cb(new Error('invalid protocol type'));

                const ws = new IsomorphicWebSocket(address, data.toString('hex') );
                ws._kadInitialized = true;

                this.pluginNodeWebsocketExtends.initializeWebSocket(this, dstContact, ws, cb);
                this.pending.pendingAdd('ws:'+this.id, 'creation', () => ws.onclose(), () => {}, KAD_OPTIONS.T_RESPONSE_TIMEOUT );

            } );

        }



        _websocketSendSerialize (dstContact, command, data) {
            const id = Math.floor( Math.random() * Number.MAX_SAFE_INTEGER );
            return {
                id,
                out: [ command, data ],
            }
        }

        _websocketSendSerialized (id, dstContact, protocol, command, data, cb)  {

            const buffer = bencode.encode( [0, id, data] );

            //connected once already already
            if (this._webSocketActiveConnectionsByContactsMap[dstContact.identityHex])
                return this._webSocketActiveConnectionsByContactsMap[dstContact.identityHex].sendWebSocketWaitAnswer( id, buffer, cb);

            this._createWebSocket( dstContact, protocol,(err, ws) => {
                if (err) return cb(err);
                ws.sendWebSocketWaitAnswer( id, buffer, cb);
            });

        }

        _websocketReceiveSerialize (id, srcContact, out ) {
            return bencode.encode( BufferHelper.serializeData([ 1, id, out] ) )
        }


    }


}